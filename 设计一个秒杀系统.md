## **秒杀的业务场景：有100个商品，每个商品有100个库存，每个商品有10万人同时抢购，要求 实时返回抢购结果，不能超卖，也不能少卖。**



### 一. 大致设计思路：

1. 整个系统，从上往下看。**前端->网关->server->数据库**。实际上越往下面走，压力越大，那么我们从整体上讲就是应该在越上层的位置限制住流量，不要让所有请求都直接打到server以致于压垮数据库。




### 二. 前端设计思路

1. 从极客时间一门课程中有看到过，秒杀场景，页面可以做**动静分离**。前端尽量让秒杀的页面发送到后端的请求尽可能的少，也就是整个秒杀页面，除了抢购按钮和其他必须要动态分配的数据，其他的全部都都不要通过请求的方式打到后端，而是**缓存到CDN二级缓存**。静态数据都去CDN里面拿。
2. **控制用户点击按钮的次数**，一旦他点击，如果没有出错或者是请求还没有回来，都不让他继续点从而导致一些多余的请求打到后端。



### 三. 网关设计思路

1. 暴力控制并发，可以在网关层直接做一个筛选，利用一个**随机算法**，随机到某一个区间的请求让他打到后端，而在区间外的让他直接返回抢购失败。
2. 网关层面做好**限流**，比如说某个IP段单位之间内只让他访问多少次。同时这样也可以防止某些恶意的请求打到后端。
3. 网关做好**负载均衡**策略，可以采用加权轮询策略。这样保证配置高的机器能够收到更多的请求，配置低的机器收到少一点的请求。



### 四. server设计思路

1. 动态数据**到缓存中**去拿。我能够想到的是我们应该有一个数据同步的服务，单独负责周期性的到数据库中去同步动态数据到缓存。
2. 秒杀：减库存这个操作必须保证原子性，而分布式场景没办法用java中的全局锁，那么只用用分布式锁，常见的有Redis（实际上Redisson实现了非常高性能的一个分布式锁，可以直接拿来用）。**通过Redis的setnx原子操作**保证拿到锁之后才能去执行减库存的操作。
3. 高并发场景下，既然我们的库存是有限的，那其实也就不用全部都放到server端去做。我们可以采用异步的方式，只要用户下单交钱了，将这些请求打到**MQ**里面异步的修改库存，保证我们的机器都是在能力范围内去MQ里面消费。
4. 实际上一些特殊的场景，**减库存的操作甚至也可以放到Redis里面做**。Redis的失效时间就是秒杀的持续时间即可。（瞎想的，不知道对不对，因为前端时间有个项目就是所有数据只和Redis打交道）然后看网上有的说可以通过lua脚本解决减库存的原子性。



### 五. 数据库设计思路

1. 实际上如果数据库上层的设计都做的很好的话，那么数据库是不会被压垮的，应该是处于正常工作状态。如果上层设计的不够完美，数据库也需要一些排队机制的话，需要修改mysql的源码进行并发排队限制。
2. 特殊场景也可以将一件商品的数量拆分成多行，这件商品的总数就是所有行数加起来的值。那么这样的话也可以减少行锁等待的时间，从而提高数据库的并发度。